/**
 * Bootstrap code
 */

#define MSG(x) movw $x, %si; call message

/**
 * Main entry into boostrap. This code will load the rest of
 * the bootloader into memory.
 */
.file "boot.S"
.text
.code16
.globl _start
_start:
    cli
    ljmp $0, $real_start    // Reset CS:IP to 0x0000:7C00

real_start:
    xorw %ax, %ax
    movw %ax, %ds
    movw %ax, %ss

    /* Setup stack */
    movw $0x2000, %sp

    sti

    /* %dl stores the drive number we booted on */
    pushw %dx

    MSG(entry_str)

    /* Test if LBA mode is supported. */
    movb $0x41, %ah
    movw $0x55aa, %bx
    int $0x13

    popw %dx
    push %dx

    jc error
    cmpw $0xaa55, %bx
    jne error
    andw $1, %cx
    jz error

    /* Read rest of bootloader from disk */
    movw $disk_address_packet, %si
    xorw %ax, %ax


error:
    MSG(error_str)
    cli
    hlt

/**
 * message:
 * prints a string to the screen
 * %si = address of null terminated string
 */
1:
    movw $0x0001, %bx
    movb $0xe, %ah
    int $0x10
message:
    lodsb
    cmpb $0, %al
    jne 1b
    ret

drive: .byte 0x80

disk_address_packet: .fill 0x10, 1, 0x0

entry_str: .asciz "GRUBHub"
error_str: .asciz "Error!"

/**
 * Generated by mkimg command.
 */
.org 0x1be - 0xc
load_start:  
    /* Start sector of the rest of the bootloader. */
    .long 1, 0
load_length: 
    /* Size of the rest of the bootloader in sectors. */
    .word 0
load_addr:
    /* Addres to load bootloader at. */
    .word 0x8000

/**
 * Block off space for MBR partition table
 */
.org 0x1be 
partition_entries: .fill 4, 16, 0x0

/**
 * Magic bytes
 */
.org 0x1fe
.word 0xaa55